trigger:
  branches:
    include:
      - '*'

pr:
  branches:
    include:
      - develop
pool:
  vmImage: 'ubuntu-latest'

variables:
  SNYK_AUTH: '45678901'
  SNYK_AUTH_TOKEN: $(SNYK_AUTH) # Securely store this in Azure DevOps pipeline variables

stages:
# Stage 1: Build UnitTest and SNYK
- stage: BuildAndTest
  displayName: 'Build Test & SNYKSCAN'
  jobs:
  - job: BuildAndTest
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x' # Specify the Node.js version
        checkLatest: true
      displayName: 'Install Node.js'
    - script: npm install
      displayName: 'Install Dependencies'
    - script: npm i sharp
      displayName: 'install image optimizer'
    - script: |
        npm install set fund false
        set cache .npm
        npm audit fix set fund false
        npm ci test 
      displayName: 'Run Unit Tests'
 
 # Step 2 integrate security scans into the CI/CD pipeline.
  - job: SnykScan
    displayName: 'SnykScan'
    dependsOn: 'BuildAndTest'
    condition: succeeded() # Only proceed if the Build and Test stage is successful
    pool:
      vmImage: ubuntu-latest
    steps:
    - script: |
        echo "Running Snyk security scan"
        npm install -g snyk 
        npm config set fund false
      displayName: 'Run Snyk Scan'
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'snyk-results.json'
        ArtifactName: 'snyk-report'
        publishLocation: 'Container'
      displayName: 'Publish Snyk Scan Results'
    - script: |
        cat snyk-results.json
        severityCount=$(jq '.vulnerabilities | map(select(.severity=="high" or .severity=="critical")) | length' snyk-results.json)
        if [ "$severityCount" -gt 0 ]; then
          echo "Critical vulnerabilities found!"
          exit 1
        fi
      displayName: 'Check for Critical Vulnerabilities'
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
      
      displayName: 'Publish Test Results'

    - task: PublishBuildArtifacts@1
      inputs:
        targetPath: $(System.DefaultWorkingDirectory)/bin/WebApp
        artifactName: WebApp 
      displayName: 'Publish Build Artifacts'

# Testing Environment Deployment   
- stage: TestDeployment
  displayName: 'Test Environment Deployment'
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - deployment: DeployToTest
    displayName: 'Deploy to Test Environment'
    environment: 'Test' # Define the environment in Azure DevOps
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "Deploying to Test Environment"
              # Add deployment scripts/commands here (e.g., ARM templates, Kubernetes manifests)
            displayName: 'Deploy Application'     
          - script: |
              echo "Running Integration Tests"
              # Command to run integration tests
            displayName: 'Run Integration Tests'
          - script: |
              echo "Running System Tests"
              # Command to run system tests
            displayName: 'Run System Tests'

          - script: |
              echo "Generating Test Results"
              # Generate and publish test reports (use tasks like PublishTestResults@2)
    
      